<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mascot Race</title>
  <style>
    :root {
      --bg: #111;
      --panel: #1b1d22;
      --panel-2: #222;
      --text: #fff;
      --muted: #9aa4ad;
      --accent: #e53935;
      --lane: #444;
      --finish: #888;
      --canvas: #0c0e12;
    }
    * { box-sizing: border-box; }
    body { margin:0; background:var(--bg); color:var(--text); font-family:system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    header {
      padding:10px 12px;
      background:var(--panel-2);
      display:flex;
      gap:12px;
      align-items:center;
      flex-wrap: wrap;
      position: sticky;
      top: 0;
      z-index: 10;
    }
    header .title { font-weight: 700; letter-spacing:.2px; }
    button {
      padding:8px 14px; border:none; border-radius:8px; cursor:pointer; background:#3a3f46; color:#fff;
      transition: transform .02s ease, background .15s ease, opacity .15s ease;
    }
    button:hover { background:#4a5058; }
    button:active { transform: translateY(1px); }
    button.primary { background:var(--accent); color:#fff; }
    button.primary:hover { filter: brightness(1.05); }
    button.secondary { background:#555; color:#fff; }
    button[disabled] { opacity:.6; cursor:not-allowed; }

    .controls {
      background: var(--panel);
      border-top: 1px solid #2a2f36;
      border-bottom: 1px solid #2a2f36;
      padding: 12px;
      display: grid;
      gap: 12px;
    }
    .row {
      display: flex; align-items: center; gap: 10px; flex-wrap: wrap;
    }
    .row .label { color: var(--muted); font-size: 14px; }
    .durations button { min-width:64px }
    .mascot-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
      gap: 10px;
    }
    .mascot-card {
      display:flex; align-items:center; gap:10px;
      padding:8px; border:1px solid #2a2f36; border-radius:10px; background:#16181d;
      cursor:pointer; user-select:none;
    }
    .mascot-card input { accent-color: var(--accent); width:18px; height:18px; }
    .mascot-card img { width:36px; height:36px; object-fit:contain; background:#0f1115; border-radius:6px; }
    .mascot-card .name { font-weight:600; font-size:14px; }
    .mascot-card.selected { outline: 2px solid #2f333a; background:#171a20; }

  canvas { display:block; width:100%; height:90vh; background:var(--canvas); }
  #winner { padding:10px; font-size:18px; font-weight:600; text-align:center; min-height: 28px; }

  /* Winner modal */
  #winModal { position: fixed; inset: 0; display: none; align-items: center; justify-content: center; z-index: 20; }
  #winModal[data-open="true"] { display: flex; }
  #winModal .modal-backdrop { position: absolute; inset: 0; background: rgba(0,0,0,.6); }
  #winModal .modal-content { position: relative; background: var(--panel); border: 1px solid #2a2f36; border-radius: 12px; padding: 16px; z-index: 1; width: min(90vw, 420px); box-shadow: 0 10px 30px rgba(0,0,0,.5); }
  #winModal .modal-body { display: grid; gap: 12px; justify-items: center; text-align: center; }
  #winModal img { width: 180px; height: 180px; object-fit: contain; background:#0f1115; border-radius: 12px; border: 1px solid #2a2f36; }
  #winModal .winner-name { font-size: 18px; font-weight: 700; }
  #winModal .modal-actions { display: flex; justify-content: center; margin-top: 10px; }

  /* Confetti overlay */
  #confettiCanvas { position: fixed; inset: 0; pointer-events: none; z-index: 25; }

  /* Responsive improvements for iPhone landscape and similar mobile landscape devices */
  @media screen and (orientation: landscape) and (max-height: 500px) {
    /* More compact header in landscape */
    header {
      padding: 6px 12px;
      gap: 8px;
    }
    
    /* Smaller font sizes and spacing */
    header .title { 
      font-size: 16px; 
    }
    
    button {
      padding: 6px 10px;
      font-size: 13px;
    }
    
    /* More compact controls section */
    .controls {
      padding: 8px 12px;
      gap: 8px;
    }
    
    .row {
      gap: 8px;
    }
    
    .row .label {
      font-size: 13px;
    }
    
    /* Optimize mascot grid for horizontal layout */
    .mascot-grid {
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 6px;
    }
    
    .mascot-card {
      padding: 6px 8px;
      gap: 8px;
    }
    
    .mascot-card img {
      width: 28px;
      height: 28px;
    }
    
    .mascot-card .name {
      font-size: 13px;
    }
    
    .mascot-card input {
      width: 16px;
      height: 16px;
    }
    
    /* Better canvas height for landscape */
    canvas {
      height: calc(100vh - 140px); /* Account for header + controls */
    }
  }

  /* Extra compact layout for very small landscape screens (like iPhone SE landscape) */
  @media screen and (orientation: landscape) and (max-height: 400px) {
    header {
      padding: 4px 8px;
      gap: 6px;
    }
    
    header .title {
      font-size: 14px;
    }
    
    button {
      padding: 4px 8px;
      font-size: 12px;
    }
    
    .controls {
      padding: 6px 8px;
      gap: 6px;
    }
    
    .mascot-grid {
      grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
      gap: 4px;
    }
    
    .mascot-card {
      padding: 4px 6px;
      gap: 6px;
    }
    
    .mascot-card img {
      width: 24px;
      height: 24px;
    }
    
    .mascot-card .name {
      font-size: 12px;
    }
    
    canvas {
      height: calc(100vh - 120px);
    }
  }
  </style>
</head>
<body>
  <header>
    <span class="title">üèÅ Mascot Race</span>

    <!-- NEW: Mode toggle -->
    <div class="row" role="group" aria-label="Mode">
      <button id="modeRace" class="primary" aria-pressed="true">Race</button>
      <button id="modeDrop" aria-pressed="false">Drop</button>
    </div>

    <div class="row durations" role="group" aria-label="Race duration">
      <button id="race30" aria-pressed="false">30s</button>
      <button id="race45" class="primary" aria-pressed="true">45s</button>
      <button id="race60" aria-pressed="false">60s</button>
    </div>
    <div class="row">
      <button id="start" class="secondary">Start Race</button>
      <button id="reset" title="Reset to start positions">Reset</button>
      <button id="muteToggle" title="Mute/unmute sounds" aria-pressed="false">üîä Sound</button>
    </div>
  </header>

  <section class="controls">
    <div class="row">
      <span class="label">Select mascots to race:</span>
    </div>
    <div id="mascotGrid" class="mascot-grid"></div>
  </section>

  <canvas id="track"></canvas>
  <div id="winner"></div>

  <!-- Winner modal -->
  <div id="winModal" aria-hidden="true">
    <div class="modal-backdrop"></div>
    <div class="modal-content" role="dialog" aria-label="Race Winner">
      <div class="modal-body">
        <img id="winnerImg" alt="Winner" />
        <div id="winnerName" class="winner-name"></div>
      </div>
      <div class="modal-actions">
        <button id="closeWin">Close</button>
      </div>
    </div>
  </div>

<script>
  // Model
  const allMascots = [
    { id:"blooper",   name:"Blooper",    img:"assets/blooper_run.png",    still:"assets/blooper.png",   color:"#e91e63" },
    { id:"uga",       name:"Uga",        img:"assets/uga_run.png",        still:"assets/uga.png",       color:"#d32f2f" },
    { id:"hairyhawk", name:"Hairy Hawk", img:"assets/hairyhawk_run.png",  still:"assets/hairyhawk.png", color:"#f44336" },
    { id:"freddy",    name:"Freddy",     img:"assets/freddy_run.png",     still:"assets/freddie.png",  color:"#ff7043" },
    { id:"trac",      name:"T-Rac",      img:"assets/T-Rac_run.png",      still:"assets/T-Rac.png",    color:"#4caf50" },
    { id:"bbill",     name:"B-Bill",     img:"assets/B-Bill_run.png",     still:"assets/B-Bill.png",   color:"#03a9f4" }
  ];

  // Elements
  const canvas = document.getElementById('track');
  const ctx = canvas.getContext('2d');
  const winnerEl = document.getElementById('winner');
  const startBtn = document.getElementById('start');
  const resetBtn = document.getElementById('reset');
  const muteToggle = document.getElementById('muteToggle');
  const durationBtns = {
    30: document.getElementById('race30'),
    45: document.getElementById('race45'),
    60: document.getElementById('race60'),
  };
  const mascotGrid = document.getElementById('mascotGrid');
  // Modal elements
  const winModal = document.getElementById('winModal');
  const winnerImgEl = document.getElementById('winnerImg');
  const winnerNameEl = document.getElementById('winnerName');
  const closeWinBtn = document.getElementById('closeWin');

  // NEW: Mode elements/state
  const modeBtns = {
    race: document.getElementById('modeRace'),
    drop: document.getElementById('modeDrop'),
  };
  const modes = { race: 'race', drop: 'drop' };
  let mode = modes.race;

  // State
  let duration = 45; // seconds
  let selected = new Set(allMascots.map(m => m.id)); // all selected by default
  let racers = [];
  let running = false;
  let startedAt = 0;
  let lastFrameAt = 0;
  let rafId = 0;
  let halfwayPlayed = false;

  // NEW: Drop-mode state (accelerate to terminal, then cruise; persists until Reset)
  let dropState = null; // { entities: [{r, x, y, vy, vt, a, landed, distance, targetT}] }

  // NEW: Audio (race mode)
  const sfx = {
    countdown: new Audio('assets/count_down_3.wav'),
    runLoop: new Audio('assets/running_loop.wav'),
    halfway: new Audio('assets/Halfway.mp3'),
  };
  sfx.runLoop.loop = true;

  // Background music
  const bgm = new Audio('assets/BKMusic.wav');
  bgm.loop = true;
  bgm.volume = 0.35; // requested default

  let muted = false;
  let bgmStarted = false;
  function ensureBgMusic(){
    if (bgmStarted) return;
    try {
      const p = bgm.play();
      if (p && typeof p.then === 'function') {
        p.then(() => { bgmStarted = true; }).catch(() => {/* try again on next gesture */});
      } else {
        bgmStarted = true;
      }
    } catch {}
  }
  function applyMute(){
    sfx.countdown.muted = muted;
    sfx.runLoop.muted = muted;
    sfx.halfway.muted = muted;
    bgm.muted = muted; // NEW: include bgm
    muteToggle.setAttribute('aria-pressed', String(muted));
    muteToggle.textContent = muted ? 'üîá Muted' : 'üîä Sound';
  }
  function stopRunLoop(){
    try { sfx.runLoop.pause(); } catch {}
    try { sfx.runLoop.currentTime = 0; } catch {}
  }
  function stopCountdown(){
    try { sfx.countdown.pause(); } catch {}
    try { sfx.countdown.currentTime = 0; } catch {}
  }
  function stopHalfway(){
    try { sfx.halfway.pause(); } catch {}
    try { sfx.halfway.currentTime = 0; } catch {}
  }
  function stopAllSfx(){ stopCountdown(); stopRunLoop(); stopHalfway(); }

  // Winner helpers
  function showWinnerPopup(m){
    const still = m.still || m.img.replace('_run', '');
    winnerImgEl.src = still;
    winnerImgEl.alt = `${m.name} photo`;
    winnerNameEl.textContent = `üèÜ Winner: ${m.name}`;
    winModal.dataset.open = 'true';
    winModal.setAttribute('aria-hidden', 'false');
    launchConfetti();
  }
  function hideWinnerPopup(){
    delete winModal.dataset.open;
    winModal.setAttribute('aria-hidden', 'true');
    const cc = document.getElementById('confettiCanvas');
    if (cc) cc.remove();
  }

  // Confetti
  function launchConfetti(durationMs = 3000){
    const existing = document.getElementById('confettiCanvas');
    if (existing) existing.remove();
    const canvas = document.createElement('canvas');
    canvas.id = 'confettiCanvas';
    document.body.appendChild(canvas);
    const c = canvas.getContext('2d');
    const resizeConfetti = () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; };
    resizeConfetti();
    const onResize = () => resizeConfetti();
    window.addEventListener('resize', onResize);

    const colors = ['#f94144','#f3722c','#f9c74f','#90be6d','#43aa8b','#577590','#ef476f','#ffd166'];
    const N = Math.min(180, Math.floor((canvas.width + canvas.height)/8));
    const parts = Array.from({length: N}, () => {
      const w = 6 + Math.random()*6;
      const h = 8 + Math.random()*10;
      return {
        x: Math.random()*canvas.width,
        y: -20 - Math.random()*canvas.height*0.5,
        vx: -80 + Math.random()*160,
        vy: 100 + Math.random()*200,
        w, h,
        c: colors[Math.floor(Math.random()*colors.length)],
        r: Math.random()*Math.PI,
        vr: (-2 + Math.random()*4),
        alpha: 1
      };
    });
    const start = performance.now();
    let raf;
    function step(t){
      const dt = 1/60; // fixed timestep
      c.clearRect(0,0,canvas.width,canvas.height);
      parts.forEach(p => {
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.vy += 200 * dt; // gravity
        p.r += p.vr * dt;
        if (p.x < -20) p.x = canvas.width + 20;
        if (p.x > canvas.width + 20) p.x = -20;
        const elapsed = t - start;
        const remain = Math.max(0, durationMs - elapsed);
        p.alpha = Math.min(1, remain / 600);
        c.save();
        c.globalAlpha = Math.max(0, p.alpha);
        c.translate(p.x, p.y);
        c.rotate(p.r);
        c.fillStyle = p.c;
        c.fillRect(-p.w/2, -p.h/2, p.w, p.h);
        c.restore();
      });
      if (t - start < durationMs){
        raf = requestAnimationFrame(step);
      } else {
        window.removeEventListener('resize', onResize);
        cancelAnimationFrame(raf);
        canvas.remove();
      }
    }
    raf = requestAnimationFrame(step);
  }

  // Utils
  function resize(){
    canvas.width = window.innerWidth;
    canvas.height = Math.max(320, Math.floor(window.innerHeight * 0.9)); // was 0.7
    if (!running) drawFrame();
  }
  window.addEventListener('resize', resize);

  class Racer {
    constructor(m, lane){
      this.m = m;
      this.lane = lane;
      this.img = new Image();
      this.img.src = m.img;
      this.progress = 0; // 0..1
      this.base = speedForDuration(duration);
      this.img.onload = () => { if (!running) drawFrame(); };
      this.img.onerror = () => console.warn('Image failed to load:', this.m.img);
    }
    resetProgress(){ this.progress = 0; }
    reSeedSpeed(){ this.base = speedForDuration(duration); }
    step(dt){ this.progress += this.base * dt; }
    draw(){
      const laneHeight = canvas.height / Math.max(1, racers.length);
      const y = this.lane*laneHeight + laneHeight/2 - 40;
      const leftPad = 80, rightPad = 160;
      const x = leftPad + (canvas.width - (leftPad + rightPad)) * Math.min(this.progress,1);
      // shadow circle
      ctx.globalAlpha = 0.25;
      ctx.fillStyle = "#000";
      ctx.beginPath();
      ctx.ellipse(x+40, y+72, 28, 10, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;
      // mascot
      ctx.drawImage(this.img, x, y, 80, 80);
      // name plate
      ctx.fillStyle = this.m.color;
      ctx.font = "600 14px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
      ctx.fillText(this.m.name, Math.max(8, x-70), y+18);
    }
  }

  function speedForDuration(d){
    // Faster for shorter durations, slower for longer
    return (1 / d) * (0.95 + Math.random()*0.1);
  }

  // NEW: Scale drop gravity/terminal based on duration (45s is baseline)
  function dropParamsForDuration(d){
    const baseline = 45;
    const scale = baseline / d; // e.g., 30s -> 1.5x faster, 60s -> 0.75x
    return {
      gravity: 600 * scale,   // px/s^2
      terminal: 220 * scale   // px/s
    };
  }

  // NEW: Reseed speeds for existing racers (when not running)
  function reSeedAllSpeeds(){
    racers.forEach(r => r.reSeedSpeed());
  }

  // UPDATED: Handle duration change (no per-drop physics tuning needed now)
  function onDurationChanged(){
    setDurationUI(duration);
    if (!running) {
      reSeedAllSpeeds();
      // dropState params are derived at start; nothing else to update here
      drawFrame();
    }
  }

  // NEW: Shared layout for Drop mode (portrait zones sized like race lanes)
  function getDropLayout(){
    const n = Math.max(1, racers.length);
    const laneH = canvas.height / n;
    const desiredZoneW = laneH;
    const zoneW = Math.min(desiredZoneW, canvas.width / n);
    const totalW = zoneW * n;
    const left = (canvas.width - totalW) / 2;
    const groundH = 80;
    const spriteW = 80, spriteH = 80, topPad = 20;
    return { n, laneH, zoneW, totalW, left, groundH, spriteW, spriteH, topPad };
  }

  // Drawing: Race
  function drawTrack(){
    ctx.fillStyle = '#0b0c10';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    const lanes = Math.max(1, racers.length);
    const laneHeight = canvas.height / lanes;
    for(let i=0;i<=lanes;i++){
      ctx.strokeStyle = '#444';
      ctx.beginPath();
      ctx.moveTo(0, i*laneHeight);
      ctx.lineTo(canvas.width, i*laneHeight);
      ctx.stroke();
    }
    // Finish line: checkered vertical strip
    const finishX = canvas.width - 100;
    const stripW = 20;
    const tile = 10;
    for (let y = 0; y < canvas.height; y += tile){
      for (let x = finishX; x < finishX + stripW; x += tile){
        const isLight = ((Math.floor((x - finishX)/tile) + Math.floor(y/tile)) % 2) === 0;
        ctx.fillStyle = isLight ? '#eee' : '#333';
        ctx.fillRect(x, y, tile, tile);
      }
    }
  }

  // UPDATED: Drawing: Drop scene (uses layout helper)
  function drawDropScene(){
    const g = ctx.createLinearGradient(0, 0, 0, canvas.height);
    g.addColorStop(0, '#0c1c2b');
    g.addColorStop(1, '#0b0c10');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,canvas.width,canvas.height);

    const L = getDropLayout();

    // vertical zone dividers
    ctx.strokeStyle = '#444';
    for (let i = 0; i <= L.n; i++) {
      const x = Math.round(L.left + i * L.zoneW) + 0.5;
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, canvas.height);
      ctx.stroke();
    }

    // ground band
    ctx.fillStyle = '#1e232b';
    ctx.fillRect(0, canvas.height - L.groundH, canvas.width, L.groundH);

    // Finish line pad (checkered) centered on ground
    const padW = 80;
    const tile = 10;
    const padX = Math.round(canvas.width/2 - padW/2);
    const padTop = canvas.height - L.groundH;
    for (let y = padTop; y < canvas.height; y += tile){
      for (let x = padX; x < padX + padW; x += tile){
        const isLight = ((Math.floor((x - padX)/tile) + Math.floor((y - padTop)/tile)) % 2) === 0;
        ctx.fillStyle = isLight ? '#eee' : '#333';
        ctx.fillRect(x, y, tile, tile);
      }
    }
  }

  // NEW: Placeholder mascots in portrait zones when idle
  function drawDropPlaceholders(){
    const L = getDropLayout();
    const spriteW = L.spriteW, spriteH = L.spriteH;
    const y = L.topPad + 10;

    for (let i = 0; i < L.n; i++){
      const r = racers[i];
      if (!r) continue;
      const zoneX = L.left + i * L.zoneW;
      const x = Math.round(zoneX + (L.zoneW - spriteW)/2);

      // parachute canopy centered above mascot
      ctx.fillStyle = r.m.color;
      ctx.beginPath();
      ctx.arc(x + spriteW/2, y + 40, 32, Math.PI, 0);
      ctx.fill();
      // lines
      ctx.strokeStyle = '#aaa';
      ctx.beginPath();
      ctx.moveTo(x + 8,  y + 40); ctx.lineTo(x + 20, y + 52);
      ctx.moveTo(x + 72, y + 40); ctx.lineTo(x + 60, y + 52);
      ctx.stroke();
      // mascot
      ctx.drawImage(r.img, x, y + 20, spriteW, spriteH);
    }
  }

  // NEW: Draw entities during active Drop run
  function drawDropEntities(){
    if (!dropState) return;
    const spriteW = 80, spriteH = 80;
    for (const e of dropState.entities){
      const x = e.x;
      const y = e.y - 20; // keep canopy above head like placeholder

      // parachute canopy
      ctx.fillStyle = e.r.m.color;
      ctx.beginPath();
      ctx.arc(x + spriteW/2, y + 40, 32, Math.PI, 0);
      ctx.fill();
      // lines
      ctx.strokeStyle = '#aaa';
      ctx.beginPath();
      ctx.moveTo(x + 8,  y + 40); ctx.lineTo(x + 20, y + 52);
      ctx.moveTo(x + 72, y + 40); ctx.lineTo(x + 60, y + 52);
      ctx.stroke();
      // mascot
      ctx.drawImage(e.r.img, x, y + 20, spriteW, spriteH);
    }
  }

  // Step physics for Drop mode (accelerate to terminal, then constant)
  function stepDrop(dt, now){
    if (!dropState) return;
    const L = getDropLayout();
    const groundY = canvas.height - L.groundH - L.spriteH;
    const targetX = canvas.width / 2;

    for (const e of dropState.entities){
      if (e.landed) continue;
      // accelerate up to terminal speed
      e.vy = Math.min(e.vt, e.vy + e.a * dt);
      e.y += e.vy * dt;

      if (e.y >= groundY){
        e.y = groundY;
        e.landed = true;
        e.distance = Math.abs((e.x + L.spriteW/2) - targetX);
        // First to land wins immediately
        if (!dropState.winner) dropState.winner = e;
      }
    }
  }

  function drawFrame(){
    if (mode === modes.race) {
      // Ensure background/lanes + finish line are drawn to clear any previous scene
      drawTrack();
      racers.forEach(r => r.draw());
    } else {
      drawDropScene();
      if (dropState) drawDropEntities();
      else drawDropPlaceholders();
    }
  }

  // Race loop
  function tick(now){
    if (!running) return;
    if (!lastFrameAt) lastFrameAt = now;
    const dt = Math.min(0.05, (now - lastFrameAt) / 1000);
    lastFrameAt = now;

    if (mode === modes.race) {
      racers.forEach(r => r.step(dt));
      racers.forEach(r => r.draw());
    } else {
      stepDrop(dt, now);
      drawDropScene();
      drawDropEntities();
      // End drop immediately when the first mascot lands
      if (dropState && dropState.winner){
        running = false;
        cancelAnimationFrame(rafId);
        const w = dropState.winner.r.m;
        winnerEl.textContent = `üèÜ Winner: ${w.name}`;
        showWinnerPopup(w);
        setControlsEnabled(true);
        drawFrame();
        return;
      }
    }

    const elapsed = (now - startedAt) / 1000;
    // Check for halfway point in Race mode
    if (mode === modes.race && !halfwayPlayed && elapsed >= duration / 2) {
      halfwayPlayed = true;
      try { sfx.halfway.currentTime = 0; sfx.halfway.play().catch(()=>{}); } catch {}
    }
    // Only end by duration in Race mode
    if (mode === modes.race && elapsed >= duration){
      running = false;
      cancelAnimationFrame(rafId);
      racers.sort((a,b)=> b.progress - a.progress);
      const w = racers[0].m;
      winnerEl.textContent = `üèÜ Winner: ${w.name}`;
      showWinnerPopup(w);
  stopRunLoop();
      setControlsEnabled(true);
      drawFrame();
      return;
    }
    rafId = requestAnimationFrame(tick);
  }

  // Controls
  function setDurationUI(selectedDuration){
    Object.entries(durationBtns).forEach(([d, btn]) => {
      const isActive = Number(d) === selectedDuration;
      btn.classList.toggle('primary', isActive);
      btn.setAttribute('aria-pressed', String(isActive));
    });
  }

  // NEW: Mode UI
  function setModeUI(selectedMode){
    const isRace = selectedMode === modes.race;
    modeBtns.race.classList.toggle('primary', isRace);
    modeBtns.drop.classList.toggle('primary', !isRace);
    modeBtns.race.setAttribute('aria-pressed', String(isRace));
    modeBtns.drop.setAttribute('aria-pressed', String(!isRace));
  }
  function setMode(next){
    if (mode === next) return;
    if (running) return; // disallow switch while running
    mode = next;
    winnerEl.textContent = '';
    dropState = null;                // clear drop entities
    racers.forEach(r => r.resetProgress()); // reset race positions
    setModeUI(mode);
    drawFrame();                     // refresh canvas now
  }

  function setControlsEnabled(enabled){
    startBtn.disabled = !enabled && true;
    resetBtn.disabled = !enabled && true;
    Object.values(durationBtns).forEach(b => b.disabled = !enabled && true);
    // NEW: disable mode toggle during run
    modeBtns.race.disabled = !enabled && true;
    modeBtns.drop.disabled = !enabled && true;
    // Disable mascot selection while running
    Array.from(mascotGrid.querySelectorAll('input[type="checkbox"]')).forEach(cb => cb.disabled = !enabled && true);
  }

  function buildMascotGrid(){
    mascotGrid.innerHTML = "";
    allMascots.forEach(m => {
      const card = document.createElement('label');
      card.className = 'mascot-card' + (selected.has(m.id) ? ' selected' : '');
      card.style.borderColor = '#2a2f36';

      const cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.checked = selected.has(m.id);
      cb.addEventListener('change', () => {
        if (cb.checked) selected.add(m.id); else selected.delete(m.id);
        card.classList.toggle('selected', cb.checked);
        rebuildRacers();
      });

      const img = document.createElement('img');
      img.alt = m.name;
      img.src = m.img;

      const name = document.createElement('span');
      name.className = 'name';
      name.textContent = m.name;

      card.appendChild(cb);
      card.appendChild(img);
      card.appendChild(name);
      mascotGrid.appendChild(card);
    });
  }

  function rebuildRacers(){
    // Keep order as in allMascots but only selected ones
    const active = allMascots.filter(m => selected.has(m.id));
    racers = active.map((m,i)=> new Racer(m,i));
    // Empty selection guard
    startBtn.disabled = active.length === 0;
    resetBtn.disabled = active.length === 0;
    if (!running) {
      winnerEl.textContent = active.length ? '' : 'Select at least one mascot to enable the race.';
      drawFrame();
    }
  }

  function startRace(){
    if (running) return;
    if (racers.length === 0){
      winnerEl.textContent = 'Select at least one mascot to start.';
      return;
    }
    if (mode === modes.drop){
      // Ensure no race SFX bleed into drop mode
      stopAllSfx();
      const L = getDropLayout();
      const spriteW = L.spriteW;
      const topY = L.topPad + 30;
      const groundY = canvas.height - L.groundH - L.spriteH;
      const dist = Math.max(1, groundY - topY);

      const entities = [];
      for (let i=0;i<L.n;i++){
        const r = racers[i];
        const zoneX = L.left + i * L.zoneW;
        const x = Math.round(zoneX + (L.zoneW - spriteW)/2);

        // randomized landing window and kinematics
        const T_land = duration * (0.6 + Math.random() * 0.3);
        const rFac = 0.65 + Math.random() * 0.2;
        const vt = dist / (T_land * rFac);
        const denom = Math.max(0.08, T_land - (dist / vt));
        const a = Math.max(20, 0.5 * vt / denom);

        entities.push({ r, x, y: topY, vy: 0, vt, a, landed: false, distance: null, targetT: T_land });
      }
      dropState = { entities, winner: null };

      startedAt = performance.now();
      lastFrameAt = 0;
      running = true;
      winnerEl.textContent = '';
      setControlsEnabled(false);
      cancelAnimationFrame(rafId);
      rafId = requestAnimationFrame(tick);
      return;
    }
    // Race mode
    // Disable controls immediately and play countdown; movement starts after countdown ends
    setControlsEnabled(false);
    winnerEl.textContent = '';

    // Prepare racers but do not start ticking until countdown finishes
    racers.forEach(r => { r.resetProgress(); r.reSeedSpeed(); });
    halfwayPlayed = false;

    // Helper to actually start the race and running loop
    const beginRun = () => {
      startedAt = performance.now();
      lastFrameAt = 0;
      running = true;
      cancelAnimationFrame(rafId);
      try { sfx.runLoop.currentTime = 0; sfx.runLoop.play().catch(()=>{}); } catch {}
      rafId = requestAnimationFrame(tick);
    };

    // Play countdown and on end, start the race
    stopCountdown(); // reset to start
    let started = false;
    const safeStart = () => { if (started) return; started = true; beginRun(); };
    const onEnded = () => { sfx.countdown.removeEventListener('ended', onEnded); safeStart(); };
    sfx.countdown.addEventListener('ended', onEnded);
    try {
      const p = sfx.countdown.play();
      if (p && typeof p.then === 'function') {
        p.catch(() => { // autoplay or play failure fallback
          setTimeout(safeStart, 500); // minimal delay if cannot play
        });
      }
    } catch {
      setTimeout(safeStart, 500);
    }
    // Absolute fallback in case 'ended' never fires
    setTimeout(safeStart, 6000);
  }

  function resetRace(){
    running = false;
    cancelAnimationFrame(rafId);
    racers.forEach(r => r.resetProgress());
    winnerEl.textContent = '';
    setControlsEnabled(true);
    dropState = null; // clear drop entities on reset
    halfwayPlayed = false;
    stopAllSfx();
    drawFrame();      // refresh canvas now
  }

  // Wire up duration buttons
  durationBtns[30].onclick = () => { duration = 30; onDurationChanged(); };
  durationBtns[45].onclick = () => { duration = 45; onDurationChanged(); };
  durationBtns[60].onclick = () => { duration = 60; onDurationChanged(); };

  // Wire up mode buttons
  modeBtns.race.onclick = () => { ensureBgMusic(); setMode(modes.race); };
  modeBtns.drop.onclick = () => { ensureBgMusic(); setMode(modes.drop); };

  // Wire up start/reset
  startBtn.onclick = () => { ensureBgMusic(); startRace(); };
  resetBtn.onclick = () => { ensureBgMusic(); resetRace(); };
  muteToggle.onclick = () => { muted = !muted; applyMute(); ensureBgMusic(); };
  closeWinBtn.onclick = () => hideWinnerPopup();
  winModal.addEventListener('click', (e) => { if (e.target === winModal || e.target.classList.contains('modal-backdrop')) hideWinnerPopup(); });

  // Init
  function init(){
    setModeUI(mode);
    setDurationUI(duration);
    buildMascotGrid();
    resize();
    rebuildRacers();
    winnerEl.textContent = '';
  applyMute();
  }
  init();

  // Add global listener for first user gesture to start BGM
  window.addEventListener('pointerdown', ensureBgMusic, { once: true });
</script>
</body>
</html>

