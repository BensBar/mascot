<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mascot Race</title>
  <style>
    :root {
      --bg: #111;
      --panel: #1b1d22;
      --panel-2: #222;
      --text: #fff;
      --muted: #9aa4ad;
      --accent: #e53935;
      --lane: #444;
      --finish: #888;
      --canvas: #0c0e12;
    }
    * { box-sizing: border-box; }
    body { margin:0; background:var(--bg); color:var(--text); font-family:system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    header {
      padding:10px 12px;
      background:var(--panel-2);
      display:flex;
      gap:12px;
      align-items:center;
      flex-wrap: wrap;
      position: sticky;
      top: 0;
      z-index: 10;
    }
    header .title { font-weight: 700; letter-spacing:.2px; }
    button {
      padding:8px 14px; border:none; border-radius:8px; cursor:pointer; background:#3a3f46; color:#fff;
      transition: transform .02s ease, background .15s ease, opacity .15s ease;
    }
    button:hover { background:#4a5058; }
    button:active { transform: translateY(1px); }
    button.primary { background:var(--accent); color:#fff; }
    button.primary:hover { filter: brightness(1.05); }
    button.secondary { background:#555; color:#fff; }
    button[disabled] { opacity:.6; cursor:not-allowed; }

    .controls {
      background: var(--panel);
      border-top: 1px solid #2a2f36;
      border-bottom: 1px solid #2a2f36;
      padding: 12px;
      display: grid;
      gap: 12px;
    }
    .row {
      display: flex; align-items: center; gap: 10px; flex-wrap: wrap;
    }
    .row .label { color: var(--muted); font-size: 14px; }
    .durations button { min-width:64px }
    .mascot-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
      gap: 10px;
    }
    .mascot-card {
      display:flex; align-items:center; gap:10px;
      padding:8px; border:1px solid #2a2f36; border-radius:10px; background:#16181d;
      cursor:pointer; user-select:none;
    }
    .mascot-card input { accent-color: var(--accent); width:18px; height:18px; }
    .mascot-card img { width:36px; height:36px; object-fit:contain; background:#0f1115; border-radius:6px; }
    .mascot-card .name { font-weight:600; font-size:14px; }
    .mascot-card.selected { outline: 2px solid #2f333a; background:#171a20; }

    canvas { display:block; width:100%; height:90vh; background:var(--canvas); }
    #winner { padding:10px; font-size:18px; font-weight:600; text-align:center; min-height: 28px; }
  </style>
</head>
<body>
  <header>
    <span class="title">üèÅ Mascot Race</span>

    <!-- NEW: Mode toggle -->
    <div class="row" role="group" aria-label="Mode">
      <button id="modeRace" class="primary" aria-pressed="true">Race</button>
      <button id="modeDrop" aria-pressed="false">Drop</button>
    </div>

    <div class="row durations" role="group" aria-label="Race duration">
      <button id="race30" aria-pressed="false">30s</button>
      <button id="race45" class="primary" aria-pressed="true">45s</button>
      <button id="race60" aria-pressed="false">60s</button>
    </div>
    <div class="row">
      <button id="start" class="secondary">Start Race</button>
      <button id="reset" title="Reset to start positions">Reset</button>
    </div>
  </header>

  <section class="controls">
    <div class="row">
      <span class="label">Select mascots to race:</span>
    </div>
    <div id="mascotGrid" class="mascot-grid"></div>
  </section>

  <canvas id="track"></canvas>
  <div id="winner"></div>

<script>
  // Model
  const allMascots = [
    { id:"blooper",   name:"Blooper",        img:"assets/blooper_run.png",   color:"#e91e63" },
    { id:"uga",       name:"Uga",            img:"assets/uga_run.png",       color:"#d32f2f" },
    { id:"hairyhawk", name:"Hairy Hawk",     img:"assets/hairyhawk_run.png", color:"#f44336" },
    { id:"freddy",    name:"Freddy",         img:"assets/freddy_run.png",    color:"#ff7043" },
    { id:"trac",      name:"T-Rac",          img:"assets/T-Rac_run.png",      color:"#4caf50" },
    { id:"bbill",     name:"B-Bill",         img:"assets/B-Bill_run.png",     color:"#03a9f4" }
  ];

  // Elements
  const canvas = document.getElementById('track');
  const ctx = canvas.getContext('2d');
  const winnerEl = document.getElementById('winner');
  const startBtn = document.getElementById('start');
  const resetBtn = document.getElementById('reset');
  const durationBtns = {
    30: document.getElementById('race30'),
    45: document.getElementById('race45'),
    60: document.getElementById('race60'),
  };
  const mascotGrid = document.getElementById('mascotGrid');

  // NEW: Mode elements/state
  const modeBtns = {
    race: document.getElementById('modeRace'),
    drop: document.getElementById('modeDrop'),
  };
  const modes = { race: 'race', drop: 'drop' };
  let mode = modes.race;

  // State
  let duration = 45; // seconds
  let selected = new Set(allMascots.map(m => m.id)); // all selected by default
  let racers = [];
  let running = false;
  let startedAt = 0;
  let lastFrameAt = 0;
  let rafId = 0;

  // NEW: Drop-mode state (accelerate to terminal, then cruise; persists until Reset)
  let dropState = null; // { entities: [{r, x, y, vy, vt, a, landed, distance, targetT}] }

  // Utils
  function resize(){
    canvas.width = window.innerWidth;
    canvas.height = Math.max(320, Math.floor(window.innerHeight * 0.9)); // was 0.7
    if (!running) drawFrame();
  }
  window.addEventListener('resize', resize);

  class Racer {
    constructor(m, lane){
      this.m = m;
      this.lane = lane;
      this.img = new Image();
      this.img.src = m.img;
      this.progress = 0; // 0..1
      this.base = speedForDuration(duration);
      this.img.onload = () => { if (!running) drawFrame(); };
      this.img.onerror = () => console.warn('Image failed to load:', this.m.img);
    }
    resetProgress(){ this.progress = 0; }
    reSeedSpeed(){ this.base = speedForDuration(duration); }
    step(dt){ this.progress += this.base * dt; }
    draw(){
      const laneHeight = canvas.height / Math.max(1, racers.length);
      const y = this.lane*laneHeight + laneHeight/2 - 40;
      const leftPad = 80, rightPad = 160;
      const x = leftPad + (canvas.width - (leftPad + rightPad)) * Math.min(this.progress,1);
      // shadow circle
      ctx.globalAlpha = 0.25;
      ctx.fillStyle = "#000";
      ctx.beginPath();
      ctx.ellipse(x+40, y+72, 28, 10, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;
      // mascot
      ctx.drawImage(this.img, x, y, 80, 80);
      // name plate
      ctx.fillStyle = this.m.color;
      ctx.font = "600 14px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
      ctx.fillText(this.m.name, Math.max(8, x-70), y+18);
    }
  }

  function speedForDuration(d){
    // Faster for shorter durations, slower for longer
    return (1 / d) * (0.95 + Math.random()*0.1);
  }

  // NEW: Scale drop gravity/terminal based on duration (45s is baseline)
  function dropParamsForDuration(d){
    const baseline = 45;
    const scale = baseline / d; // e.g., 30s -> 1.5x faster, 60s -> 0.75x
    return {
      gravity: 600 * scale,   // px/s^2
      terminal: 220 * scale   // px/s
    };
  }

  // NEW: Reseed speeds for existing racers (when not running)
  function reSeedAllSpeeds(){
    racers.forEach(r => r.reSeedSpeed());
  }

  // UPDATED: Handle duration change (no per-drop physics tuning needed now)
  function onDurationChanged(){
    setDurationUI(duration);
    if (!running) {
      reSeedAllSpeeds();
      // dropState params are derived at start; nothing else to update here
      drawFrame();
    }
  }

  // NEW: Shared layout for Drop mode (portrait zones sized like race lanes)
  function getDropLayout(){
    const n = Math.max(1, racers.length);
    const laneH = canvas.height / n;
    const desiredZoneW = laneH;
    const zoneW = Math.min(desiredZoneW, canvas.width / n);
    const totalW = zoneW * n;
    const left = (canvas.width - totalW) / 2;
    const groundH = 80;
    const spriteW = 80, spriteH = 80, topPad = 20;
    return { n, laneH, zoneW, totalW, left, groundH, spriteW, spriteH, topPad };
  }

  // Drawing: Race
  function drawTrack(){
    ctx.fillStyle = '#0b0c10';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    const lanes = Math.max(1, racers.length);
    const laneHeight = canvas.height / lanes;
    for(let i=0;i<=lanes;i++){
      ctx.strokeStyle = '#444';
      ctx.beginPath();
      ctx.moveTo(0, i*laneHeight);
      ctx.lineTo(canvas.width, i*laneHeight);
      ctx.stroke();
    }
    // Finish line: checkered vertical strip
    const finishX = canvas.width - 100;
    const stripW = 20;
    const tile = 10;
    for (let y = 0; y < canvas.height; y += tile){
      for (let x = finishX; x < finishX + stripW; x += tile){
        const isLight = ((Math.floor((x - finishX)/tile) + Math.floor(y/tile)) % 2) === 0;
        ctx.fillStyle = isLight ? '#eee' : '#333';
        ctx.fillRect(x, y, tile, tile);
      }
    }
  }

  // UPDATED: Drawing: Drop scene (uses layout helper)
  function drawDropScene(){
    const g = ctx.createLinearGradient(0, 0, 0, canvas.height);
    g.addColorStop(0, '#0c1c2b');
    g.addColorStop(1, '#0b0c10');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,canvas.width,canvas.height);

    const L = getDropLayout();

    // vertical zone dividers
    ctx.strokeStyle = '#444';
    for (let i = 0; i <= L.n; i++) {
      const x = Math.round(L.left + i * L.zoneW) + 0.5;
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, canvas.height);
      ctx.stroke();
    }

    // ground band
    ctx.fillStyle = '#1e232b';
    ctx.fillRect(0, canvas.height - L.groundH, canvas.width, L.groundH);

    // Finish line pad (checkered) centered on ground
    const padW = 80;
    const tile = 10;
    const padX = Math.round(canvas.width/2 - padW/2);
    const padTop = canvas.height - L.groundH;
    for (let y = padTop; y < canvas.height; y += tile){
      for (let x = padX; x < padX + padW; x += tile){
        const isLight = ((Math.floor((x - padX)/tile) + Math.floor((y - padTop)/tile)) % 2) === 0;
        ctx.fillStyle = isLight ? '#eee' : '#333';
        ctx.fillRect(x, y, tile, tile);
      }
    }
  }

  // NEW: Placeholder mascots in portrait zones when idle
  function drawDropPlaceholders(){
    const L = getDropLayout();
    const spriteW = L.spriteW, spriteH = L.spriteH;
    const y = L.topPad + 10;

    for (let i = 0; i < L.n; i++){
      const r = racers[i];
      if (!r) continue;
      const zoneX = L.left + i * L.zoneW;
      const x = Math.round(zoneX + (L.zoneW - spriteW)/2);

      // parachute canopy centered above mascot
      ctx.fillStyle = r.m.color;
      ctx.beginPath();
      ctx.arc(x + spriteW/2, y + 40, 32, Math.PI, 0);
      ctx.fill();
      // lines
      ctx.strokeStyle = '#aaa';
      ctx.beginPath();
      ctx.moveTo(x + 8,  y + 40); ctx.lineTo(x + 20, y + 52);
      ctx.moveTo(x + 72, y + 40); ctx.lineTo(x + 60, y + 52);
      ctx.stroke();
      // mascot
      ctx.drawImage(r.img, x, y + 20, spriteW, spriteH);
    }
  }

  // NEW: Draw entities during active Drop run
  function drawDropEntities(){
    if (!dropState) return;
    const spriteW = 80, spriteH = 80;
    for (const e of dropState.entities){
      const x = e.x;
      const y = e.y - 20; // keep canopy above head like placeholder

      // parachute canopy
      ctx.fillStyle = e.r.m.color;
      ctx.beginPath();
      ctx.arc(x + spriteW/2, y + 40, 32, Math.PI, 0);
      ctx.fill();
      // lines
      ctx.strokeStyle = '#aaa';
      ctx.beginPath();
      ctx.moveTo(x + 8,  y + 40); ctx.lineTo(x + 20, y + 52);
      ctx.moveTo(x + 72, y + 40); ctx.lineTo(x + 60, y + 52);
      ctx.stroke();
      // mascot
      ctx.drawImage(e.r.img, x, y + 20, spriteW, spriteH);
    }
  }

  // Step physics for Drop mode (accelerate to terminal, then constant)
  function stepDrop(dt, now){
    if (!dropState) return;
    const L = getDropLayout();
    const groundY = canvas.height - L.groundH - L.spriteH;
    const targetX = canvas.width / 2;

    for (const e of dropState.entities){
      if (e.landed) continue;
      // accelerate up to terminal speed
      e.vy = Math.min(e.vt, e.vy + e.a * dt);
      e.y += e.vy * dt;

      if (e.y >= groundY){
        e.y = groundY;
        e.landed = true;
        e.distance = Math.abs((e.x + L.spriteW/2) - targetX);
        // First to land wins immediately
        if (!dropState.winner) dropState.winner = e;
      }
    }
  }

  function drawFrame(){
    if (mode === modes.race) {
      // Ensure background/lanes + finish line are drawn to clear any previous scene
      drawTrack();
      racers.forEach(r => r.draw());
    } else {
      drawDropScene();
      if (dropState) drawDropEntities();
      else drawDropPlaceholders();
    }
  }

  // Race loop
  function tick(now){
    if (!running) return;
    if (!lastFrameAt) lastFrameAt = now;
    const dt = Math.min(0.05, (now - lastFrameAt) / 1000);
    lastFrameAt = now;

    if (mode === modes.race) {
      racers.forEach(r => r.step(dt));
      racers.forEach(r => r.draw());
    } else {
      stepDrop(dt, now);
      drawDropScene();
      drawDropEntities();
      // End drop immediately when the first mascot lands
      if (dropState && dropState.winner){
        running = false;
        cancelAnimationFrame(rafId);
        winnerEl.textContent = `üèÜ Winner: ${dropState.winner.r.m.name}`;
        setControlsEnabled(true);
        drawFrame();
        return;
      }
    }

    const elapsed = (now - startedAt) / 1000;
    // Only end by duration in Race mode
    if (mode === modes.race && elapsed >= duration){
      running = false;
      cancelAnimationFrame(rafId);
      racers.sort((a,b)=> b.progress - a.progress);
      winnerEl.textContent = `üèÜ Winner: ${racers[0].m.name}`;
      setControlsEnabled(true);
      drawFrame();
      return;
    }
    rafId = requestAnimationFrame(tick);
  }

  // Controls
  function setDurationUI(selectedDuration){
    Object.entries(durationBtns).forEach(([d, btn]) => {
      const isActive = Number(d) === selectedDuration;
      btn.classList.toggle('primary', isActive);
      btn.setAttribute('aria-pressed', String(isActive));
    });
  }

  // NEW: Mode UI
  function setModeUI(selectedMode){
    const isRace = selectedMode === modes.race;
    modeBtns.race.classList.toggle('primary', isRace);
    modeBtns.drop.classList.toggle('primary', !isRace);
    modeBtns.race.setAttribute('aria-pressed', String(isRace));
    modeBtns.drop.setAttribute('aria-pressed', String(!isRace));
  }
  function setMode(next){
    if (mode === next) return;
    if (running) return; // disallow switch while running
    mode = next;
    winnerEl.textContent = '';
    dropState = null;                // clear drop entities
    racers.forEach(r => r.resetProgress()); // reset race positions
    setModeUI(mode);
    drawFrame();                     // refresh canvas now
  }

  function setControlsEnabled(enabled){
    startBtn.disabled = !enabled && true;
    resetBtn.disabled = !enabled && true;
    Object.values(durationBtns).forEach(b => b.disabled = !enabled && true);
    // NEW: disable mode toggle during run
    modeBtns.race.disabled = !enabled && true;
    modeBtns.drop.disabled = !enabled && true;
    // Disable mascot selection while running
    Array.from(mascotGrid.querySelectorAll('input[type="checkbox"]')).forEach(cb => cb.disabled = !enabled && true);
  }

  function buildMascotGrid(){
    mascotGrid.innerHTML = "";
    allMascots.forEach(m => {
      const card = document.createElement('label');
      card.className = 'mascot-card' + (selected.has(m.id) ? ' selected' : '');
      card.style.borderColor = '#2a2f36';

      const cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.checked = selected.has(m.id);
      cb.addEventListener('change', () => {
        if (cb.checked) selected.add(m.id); else selected.delete(m.id);
        card.classList.toggle('selected', cb.checked);
        rebuildRacers();
      });

      const img = document.createElement('img');
      img.alt = m.name;
      img.src = m.img;

      const name = document.createElement('span');
      name.className = 'name';
      name.textContent = m.name;

      card.appendChild(cb);
      card.appendChild(img);
      card.appendChild(name);
      mascotGrid.appendChild(card);
    });
  }

  function rebuildRacers(){
    // Keep order as in allMascots but only selected ones
    const active = allMascots.filter(m => selected.has(m.id));
    racers = active.map((m,i)=> new Racer(m,i));
    // Empty selection guard
    startBtn.disabled = active.length === 0;
    resetBtn.disabled = active.length === 0;
    if (!running) {
      winnerEl.textContent = active.length ? '' : 'Select at least one mascot to enable the race.';
      drawFrame();
    }
  }

  function startRace(){
    if (running) return;
    if (racers.length === 0){
      winnerEl.textContent = 'Select at least one mascot to start.';
      return;
    }
    if (mode === modes.drop){
      const L = getDropLayout();
      const spriteW = L.spriteW;
      const topY = L.topPad + 30;
      const groundY = canvas.height - L.groundH - L.spriteH;
      const dist = Math.max(1, groundY - topY);

      const entities = [];
      for (let i=0;i<L.n;i++){
        const r = racers[i];
        const zoneX = L.left + i * L.zoneW;
        const x = Math.round(zoneX + (L.zoneW - spriteW)/2);

        // randomized landing window and kinematics
        const T_land = duration * (0.6 + Math.random() * 0.3);
        const rFac = 0.65 + Math.random() * 0.2;
        const vt = dist / (T_land * rFac);
        const denom = Math.max(0.08, T_land - (dist / vt));
        const a = Math.max(20, 0.5 * vt / denom);

        entities.push({ r, x, y: topY, vy: 0, vt, a, landed: false, distance: null, targetT: T_land });
      }
      dropState = { entities, winner: null };

      startedAt = performance.now();
      lastFrameAt = 0;
      running = true;
      winnerEl.textContent = '';
      setControlsEnabled(false);
      cancelAnimationFrame(rafId);
      rafId = requestAnimationFrame(tick);
      return;
    }
    // Race mode
    racers.forEach(r => { r.resetProgress(); r.reSeedSpeed(); });
    startedAt = performance.now();
    lastFrameAt = 0;
    running = true;
    winnerEl.textContent = '';
    setControlsEnabled(false);
    cancelAnimationFrame(rafId);
    rafId = requestAnimationFrame(tick);
  }

  function resetRace(){
    running = false;
    cancelAnimationFrame(rafId);
    racers.forEach(r => r.resetProgress());
    winnerEl.textContent = '';
    setControlsEnabled(true);
    dropState = null; // clear drop entities on reset
    drawFrame();      // refresh canvas now
  }

  // Wire up duration buttons
  durationBtns[30].onclick = () => { duration = 30; onDurationChanged(); };
  durationBtns[45].onclick = () => { duration = 45; onDurationChanged(); };
  durationBtns[60].onclick = () => { duration = 60; onDurationChanged(); };

  // Wire up mode buttons
  modeBtns.race.onclick = () => setMode(modes.race);
  modeBtns.drop.onclick = () => setMode(modes.drop);

  // Wire up start/reset
  startBtn.onclick = startRace;
  resetBtn.onclick = resetRace;

  // Init
  function init(){
    setModeUI(mode);
    setDurationUI(duration);
    buildMascotGrid();
    resize();
    rebuildRacers();
    winnerEl.textContent = '';
  }
  init();
</script>
</body>
</html>

